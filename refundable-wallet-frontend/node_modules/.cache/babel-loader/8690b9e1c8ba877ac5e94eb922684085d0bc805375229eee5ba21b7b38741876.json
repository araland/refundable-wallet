{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Web3Context, Web3ConfigEvent } from 'web3-core';\nimport { ContractExecutionError, ContractTransactionDataAndInputError, SubscriptionError, Web3ContractError } from 'web3-errors';\nimport { createAccessList, call, estimateGas, getLogs, sendTransaction, decodeEventABI, NewHeadsSubscription, ALL_EVENTS, ALL_EVENTS_ABI } from 'web3-eth';\nimport { encodeEventSignature, encodeFunctionSignature, decodeContractErrorData, isAbiErrorFragment, isAbiEventFragment, isAbiFunctionFragment, jsonInterfaceMethodToString } from 'web3-eth-abi';\nimport { BlockTags, DEFAULT_RETURN_FORMAT } from 'web3-types';\nimport { format, isDataFormat, keccak256, toChecksumAddress } from 'web3-utils';\nimport { isNullish, validator, utils as validatorUtils, Web3ValidatorError } from 'web3-validator';\nimport { decodeMethodReturn, encodeEventABI, encodeMethodABI } from './encoding.js';\nimport { LogsSubscription } from './log_subscription.js';\nimport { getCreateAccessListParams, getEstimateGasParams, getEthTxCallParams, getSendTxParams, isContractInitOptions, isWeb3ContractContext } from './utils.js';\nconst contractSubscriptions = {\n  logs: LogsSubscription,\n  newHeads: NewHeadsSubscription,\n  newBlockHeaders: NewHeadsSubscription\n};\n/**\n * The class designed to interact with smart contracts on the Ethereum blockchain.\n */\nexport class Contract extends Web3Context {\n  constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {\n    var _a, _b, _c;\n    // eslint-disable-next-line no-nested-ternary\n    const options = isContractInitOptions(addressOrOptionsOrContext) ? addressOrOptionsOrContext : isContractInitOptions(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : undefined;\n    let contractContext;\n    if (isWeb3ContractContext(addressOrOptionsOrContext)) {\n      contractContext = addressOrOptionsOrContext;\n    } else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {\n      contractContext = optionsOrContextOrReturnFormat;\n    } else {\n      contractContext = contextOrReturnFormat;\n    }\n    let provider;\n    if (typeof addressOrOptionsOrContext === 'object' && 'provider' in addressOrOptionsOrContext) {\n      provider = addressOrOptionsOrContext.provider;\n    } else if (typeof optionsOrContextOrReturnFormat === 'object' && 'provider' in optionsOrContextOrReturnFormat) {\n      provider = optionsOrContextOrReturnFormat.provider;\n    } else if (typeof contextOrReturnFormat === 'object' && 'provider' in contextOrReturnFormat) {\n      provider = contextOrReturnFormat.provider;\n    } else {\n      provider = Contract.givenProvider;\n    }\n    super(Object.assign(Object.assign({}, contractContext), {\n      provider,\n      registeredSubscriptions: contractSubscriptions\n    }));\n    /**\n     * Set to true if you want contracts' defaults to sync with global defaults.\n     */\n    this.syncWithContext = false;\n    this._functions = {};\n    if (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input) && this.config.contractDataInputFill !== 'both') throw new ContractTransactionDataAndInputError({\n      data: options.data,\n      input: options.input\n    });\n    this._overloadedMethodAbis = new Map();\n    // eslint-disable-next-line no-nested-ternary\n    const returnDataFormat = isDataFormat(contextOrReturnFormat) ? contextOrReturnFormat : isDataFormat(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : returnFormat !== null && returnFormat !== void 0 ? returnFormat : DEFAULT_RETURN_FORMAT;\n    const address = typeof addressOrOptionsOrContext === 'string' ? addressOrOptionsOrContext : undefined;\n    this.config.contractDataInputFill = (_a = options === null || options === void 0 ? void 0 : options.dataInputFill) !== null && _a !== void 0 ? _a : this.config.contractDataInputFill;\n    this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);\n    if (!isNullish(address)) {\n      this._parseAndSetAddress(address, returnDataFormat);\n    }\n    this.options = {\n      address,\n      jsonInterface: this._jsonInterface,\n      gas: (_b = options === null || options === void 0 ? void 0 : options.gas) !== null && _b !== void 0 ? _b : options === null || options === void 0 ? void 0 : options.gasLimit,\n      gasPrice: options === null || options === void 0 ? void 0 : options.gasPrice,\n      from: options === null || options === void 0 ? void 0 : options.from,\n      input: options === null || options === void 0 ? void 0 : options.input,\n      data: options === null || options === void 0 ? void 0 : options.data\n    };\n    this.syncWithContext = (_c = options === null || options === void 0 ? void 0 : options.syncWithContext) !== null && _c !== void 0 ? _c : false;\n    if (contractContext instanceof Web3Context) {\n      this.subscribeToContextEvents(contractContext);\n    }\n    Object.defineProperty(this.options, 'address', {\n      set: value => this._parseAndSetAddress(value, returnDataFormat),\n      get: () => this._address\n    });\n    Object.defineProperty(this.options, 'jsonInterface', {\n      set: value => this._parseAndSetJsonInterface(value, returnDataFormat),\n      get: () => this._jsonInterface\n    });\n    if (contractContext instanceof Web3Context) {\n      contractContext.on(Web3ConfigEvent.CONFIG_CHANGE, event => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.setConfig({\n          [event.name]: event.newValue\n        });\n      });\n    }\n  }\n  /**\n   * Subscribe to an event.\n   *\n   * ```ts\n   * await myContract.events.MyEvent([options])\n   * ```\n   *\n   * There is a special event `allEvents` that can be used to subscribe all events.\n   *\n   * ```ts\n   * await myContract.events.allEvents([options])\n   * ```\n   *\n   * @returns - When individual event is accessed will returns {@link ContractBoundEvent} object\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * Creates a transaction object for that method, which then can be `called`, `send`, `estimated`, `createAccessList` , or `ABI encoded`.\n   *\n   * The methods of this smart contract are available through:\n   *\n   * The name: `myContract.methods.myMethod(123)`\n   * The name with parameters: `myContract.methods['myMethod(uint256)'](123)`\n   * The signature `myContract.methods['0x58cf5f10'](123)`\n   *\n   * This allows calling functions with same name but different parameters from the JavaScript contract object.\n   *\n   * \\> The method signature does not provide a type safe interface, so we recommend to use method `name` instead.\n   *\n   * ```ts\n   * // calling a method\n   * const result = await myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\n   *\n   * // or sending and using a promise\n   * const receipt = await myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\n   *\n   * // or sending and using the events\n   * const sendObject = myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'});\n   * sendObject.on('transactionHash', function(hash){\n   *   ...\n   * });\n   * sendObject.on('receipt', function(receipt){\n   *   ...\n   * });\n   * sendObject.on('confirmation', function(confirmationNumber, receipt){\n   *   ...\n   * });\n   * sendObject.on('error', function(error, receipt) {\n   *   ...\n   * });\n   * ```\n   *\n   * @returns - Either returns {@link PayableMethodObject} or {@link NonPayableMethodObject} based on the definitions of the ABI of that contract.\n   */\n  get methods() {\n    return this._methods;\n  }\n  /**\n   * Clones the current contract instance. This doesn't deploy contract on blockchain and only creates a local clone.\n   *\n   * @returns - The new contract instance.\n   *\n   * ```ts\n   * const contract1 = new eth.Contract(abi, address, {gasPrice: '12345678', from: fromAddress});\n   *\n   * const contract2 = contract1.clone();\n   * contract2.options.address = address2;\n   *\n   * (contract1.options.address !== contract2.options.address);\n   * > true\n   * ```\n   */\n  clone() {\n    let newContract;\n    if (this.options.address) {\n      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {\n        gas: this.options.gas,\n        gasPrice: this.options.gasPrice,\n        from: this.options.from,\n        input: this.options.input,\n        data: this.options.data,\n        provider: this.currentProvider,\n        syncWithContext: this.syncWithContext,\n        dataInputFill: this.config.contractDataInputFill\n      }, this.getContextObject());\n    } else {\n      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {\n        gas: this.options.gas,\n        gasPrice: this.options.gasPrice,\n        from: this.options.from,\n        input: this.options.input,\n        data: this.options.data,\n        provider: this.currentProvider,\n        syncWithContext: this.syncWithContext,\n        dataInputFill: this.config.contractDataInputFill\n      }, this.getContextObject());\n    }\n    if (this.context) newContract.subscribeToContextEvents(this.context);\n    return newContract;\n  }\n  /**\n   * Call this function to deploy the contract to the blockchain. After successful deployment the promise will resolve with a new contract instance.\n   *\n   * ```ts\n   * myContract.deploy({\n   *   input: '0x12345...', // data keyword can be used, too. If input is used, data will be ignored.\n   *   arguments: [123, 'My String']\n   * })\n   * .send({\n   *   from: '0x1234567890123456789012345678901234567891',\n   *   gas: 1500000,\n   *   gasPrice: '30000000000000'\n   * }, function(error, transactionHash){ ... })\n   * .on('error', function(error){ ... })\n   * .on('transactionHash', function(transactionHash){ ... })\n   * .on('receipt', function(receipt){\n   *  console.log(receipt.contractAddress) // contains the new contract address\n   * })\n   * .on('confirmation', function(confirmationNumber, receipt){ ... })\n   * .then(function(newContractInstance){\n   *   console.log(newContractInstance.options.address) // instance with the new contract address\n   * });\n   *\n   *\n   * // When the data is already set as an option to the contract itself\n   * myContract.options.data = '0x12345...';\n   *\n   * myContract.deploy({\n   *   arguments: [123, 'My String']\n   * })\n   * .send({\n   *   from: '0x1234567890123456789012345678901234567891',\n   *   gas: 1500000,\n   *   gasPrice: '30000000000000'\n   * })\n   * .then(function(newContractInstance){\n   *   console.log(newContractInstance.options.address) // instance with the new contract address\n   * });\n   *\n   *\n   * // Simply encoding\n   * myContract.deploy({\n   *   input: '0x12345...',\n   *   arguments: [123, 'My String']\n   * })\n   * .encodeABI();\n   * > '0x12345...0000012345678765432'\n   *\n   *\n   * // Gas estimation\n   * myContract.deploy({\n   *   input: '0x12345...',\n   *   arguments: [123, 'My String']\n   * })\n   * .estimateGas(function(err, gas){\n   *   console.log(gas);\n   * });\n   * ```\n   *\n   * @returns - The transaction object\n   */\n  deploy(deployOptions) {\n    var _a, _b, _c;\n    let abi = this._jsonInterface.find(j => j.type === 'constructor');\n    if (!abi) {\n      abi = {\n        type: 'constructor',\n        inputs: [],\n        stateMutability: ''\n      };\n    }\n    const _input = format({\n      format: 'bytes'\n    }, (_a = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.input) !== null && _a !== void 0 ? _a : this.options.input, DEFAULT_RETURN_FORMAT);\n    const _data = format({\n      format: 'bytes'\n    }, (_b = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.data) !== null && _b !== void 0 ? _b : this.options.data, DEFAULT_RETURN_FORMAT);\n    if ((!_input || _input.trim() === '0x') && (!_data || _data.trim() === '0x')) {\n      throw new Web3ContractError('contract creation without any data provided.');\n    }\n    const args = (_c = deployOptions === null || deployOptions === void 0 ? void 0 : deployOptions.arguments) !== null && _c !== void 0 ? _c : [];\n    const contractOptions = Object.assign(Object.assign({}, this.options), {\n      input: _input,\n      data: _data\n    });\n    const deployData = _input !== null && _input !== void 0 ? _input : _data;\n    return {\n      arguments: args,\n      send: options => {\n        const modifiedOptions = Object.assign({}, options);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._contractMethodDeploySend(abi, args, modifiedOptions, contractOptions);\n      },\n      estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter(this, void 0, void 0, function* () {\n        const modifiedOptions = Object.assign({}, options);\n        return this._contractMethodEstimateGas({\n          abi: abi,\n          params: args,\n          returnFormat,\n          options: modifiedOptions,\n          contractOptions\n        });\n      }),\n      encodeABI: () => encodeMethodABI(abi, args, format({\n        format: 'bytes'\n      }, deployData, DEFAULT_RETURN_FORMAT))\n    };\n  }\n  getPastEvents(param1, param2, param3) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const eventName = typeof param1 === 'string' ? param1 : ALL_EVENTS;\n      const options =\n      // eslint-disable-next-line no-nested-ternary\n      typeof param1 !== 'string' && !isDataFormat(param1) ? param1 : !isDataFormat(param2) ? param2 : {};\n      // eslint-disable-next-line no-nested-ternary\n      const returnFormat = isDataFormat(param1) ? param1 : isDataFormat(param2) ? param2 : param3 !== null && param3 !== void 0 ? param3 : DEFAULT_RETURN_FORMAT;\n      const abi = eventName === 'allEvents' || eventName === ALL_EVENTS ? ALL_EVENTS_ABI : this._jsonInterface.find(j => 'name' in j && j.name === eventName);\n      if (!abi) {\n        throw new Web3ContractError(`Event ${eventName} not found.`);\n      }\n      const {\n        fromBlock,\n        toBlock,\n        topics,\n        address\n      } = encodeEventABI(this.options, abi, options !== null && options !== void 0 ? options : {});\n      const logs = yield getLogs(this, {\n        fromBlock,\n        toBlock,\n        topics,\n        address\n      }, returnFormat);\n      const decodedLogs = logs.map(log => typeof log === 'string' ? log : decodeEventABI(abi, log, this._jsonInterface, returnFormat));\n      const filter = (_a = options === null || options === void 0 ? void 0 : options.filter) !== null && _a !== void 0 ? _a : {};\n      const filterKeys = Object.keys(filter);\n      if (filterKeys.length > 0) {\n        return decodedLogs.filter(log => {\n          if (typeof log === 'string') return true;\n          return filterKeys.every(key => {\n            var _a;\n            if (Array.isArray(filter[key])) {\n              return filter[key].some(v => String(log.returnValues[key]).toUpperCase() === String(v).toUpperCase());\n            }\n            const inputAbi = (_a = abi.inputs) === null || _a === void 0 ? void 0 : _a.filter(input => input.name === key)[0];\n            if ((inputAbi === null || inputAbi === void 0 ? void 0 : inputAbi.indexed) && inputAbi.type === 'string') {\n              const hashedIndexedString = keccak256(filter[key]);\n              if (hashedIndexedString === String(log.returnValues[key])) return true;\n            }\n            return String(log.returnValues[key]).toUpperCase() === String(filter[key]).toUpperCase();\n          });\n        });\n      }\n      return decodedLogs;\n    });\n  }\n  _parseAndSetAddress(value, returnFormat = DEFAULT_RETURN_FORMAT) {\n    this._address = value ? toChecksumAddress(format({\n      format: 'address'\n    }, value, returnFormat)) : value;\n  }\n  _parseAndSetJsonInterface(abis, returnFormat = DEFAULT_RETURN_FORMAT) {\n    var _a, _b, _c, _d, _e;\n    this._functions = {};\n    this._methods = {};\n    this._events = {};\n    let result = [];\n    const functionsAbi = abis.filter(abi => abi.type !== 'error');\n    const errorsAbi = abis.filter(abi => isAbiErrorFragment(abi));\n    for (const a of functionsAbi) {\n      const abi = Object.assign(Object.assign({}, a), {\n        signature: ''\n      });\n      if (isAbiFunctionFragment(abi)) {\n        const methodName = jsonInterfaceMethodToString(abi);\n        const methodSignature = encodeFunctionSignature(methodName);\n        abi.signature = methodSignature;\n        // make constant and payable backwards compatible\n        abi.constant = (_b = (_a = abi.stateMutability === 'view') !== null && _a !== void 0 ? _a : abi.stateMutability === 'pure') !== null && _b !== void 0 ? _b : abi.constant;\n        abi.payable = (_c = abi.stateMutability === 'payable') !== null && _c !== void 0 ? _c : abi.payable;\n        this._overloadedMethodAbis.set(abi.name, [...((_d = this._overloadedMethodAbis.get(abi.name)) !== null && _d !== void 0 ? _d : []), abi]);\n        const abiFragment = (_e = this._overloadedMethodAbis.get(abi.name)) !== null && _e !== void 0 ? _e : [];\n        const contractMethod = this._createContractMethod(abiFragment, errorsAbi);\n        this._functions[methodName] = {\n          signature: methodSignature,\n          method: contractMethod\n        };\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[abi.name] = this._functions[methodName].method;\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[methodName] = this._functions[methodName].method;\n        // We don't know a particular type of the Abi method so can't type check\n        this._methods[methodSignature] = this._functions[methodName].method;\n      } else if (isAbiEventFragment(abi)) {\n        const eventName = jsonInterfaceMethodToString(abi);\n        const eventSignature = encodeEventSignature(eventName);\n        const event = this._createContractEvent(abi, returnFormat);\n        abi.signature = eventSignature;\n        if (!(eventName in this._events) || abi.name === 'bound') {\n          // It's a private type and we don't want to expose it and no need to check\n          this._events[eventName] = event;\n        }\n        // It's a private type and we don't want to expose it and no need to check\n        this._events[abi.name] = event;\n        // It's a private type and we don't want to expose it and no need to check\n        this._events[eventSignature] = event;\n      }\n      result = [...result, abi];\n    }\n    this._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);\n    this._jsonInterface = [...result];\n    this._errorsInterface = errorsAbi;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _getAbiParams(abi, params) {\n    var _a;\n    try {\n      return validatorUtils.transformJsonDataToAbiFormat((_a = abi.inputs) !== null && _a !== void 0 ? _a : [], params);\n    } catch (error) {\n      throw new Web3ContractError(`Invalid parameters for method ${abi.name}: ${error.message}`);\n    }\n  }\n  _createContractMethod(abiArr, errorsAbis) {\n    const abi = abiArr[abiArr.length - 1];\n    return (...params) => {\n      var _a, _b;\n      let abiParams;\n      const abis = (_a = this._overloadedMethodAbis.get(abi.name)) !== null && _a !== void 0 ? _a : [];\n      let methodAbi = abis[0];\n      const internalErrorsAbis = errorsAbis;\n      const arrayOfAbis = abis.filter(_abi => {\n        var _a;\n        return ((_a = _abi.inputs) !== null && _a !== void 0 ? _a : []).length === params.length;\n      });\n      if (abis.length === 1 || arrayOfAbis.length === 0) {\n        abiParams = this._getAbiParams(methodAbi, params);\n        validator.validate((_b = abi.inputs) !== null && _b !== void 0 ? _b : [], abiParams);\n      } else {\n        const errors = [];\n        for (const _abi of arrayOfAbis) {\n          try {\n            abiParams = this._getAbiParams(_abi, params);\n            validator.validate(_abi.inputs, abiParams);\n            methodAbi = _abi;\n            break;\n          } catch (e) {\n            errors.push(e);\n          }\n        }\n        if (errors.length === arrayOfAbis.length) {\n          throw new Web3ValidatorError(errors);\n        }\n      }\n      const methods = {\n        arguments: abiParams,\n        call: (options, block) => __awaiter(this, void 0, void 0, function* () {\n          return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block);\n        }),\n        send: options => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),\n        estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter(this, void 0, void 0, function* () {\n          return this._contractMethodEstimateGas({\n            abi: methodAbi,\n            params: abiParams,\n            returnFormat,\n            options\n          });\n        }),\n        encodeABI: () => encodeMethodABI(methodAbi, abiParams),\n        createAccessList: (options, block) => __awaiter(this, void 0, void 0, function* () {\n          return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block);\n        })\n      };\n      if (methodAbi.stateMutability === 'payable') {\n        return methods;\n      }\n      return methods;\n    };\n  }\n  _contractMethodCall(abi, params, errorsAbi, options, block) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getEthTxCallParams({\n        abi,\n        params,\n        options: Object.assign(Object.assign({}, options), {\n          dataInputFill: this.config.contractDataInputFill\n        }),\n        contractOptions: Object.assign(Object.assign({}, this.options), {\n          from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.config.defaultAccount\n        })\n      });\n      try {\n        const result = yield call(this, tx, block, DEFAULT_RETURN_FORMAT);\n        return decodeMethodReturn(abi, result);\n      } catch (error) {\n        if (error instanceof ContractExecutionError) {\n          // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n          decodeContractErrorData(errorsAbi, error.innerError);\n        }\n        throw error;\n      }\n    });\n  }\n  _contractMethodCreateAccessList(abi, params, errorsAbi, options, block) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getCreateAccessListParams({\n        abi,\n        params,\n        options: Object.assign(Object.assign({}, options), {\n          dataInputFill: this.config.contractDataInputFill\n        }),\n        contractOptions: Object.assign(Object.assign({}, this.options), {\n          from: (_a = this.options.from) !== null && _a !== void 0 ? _a : this.config.defaultAccount\n        })\n      });\n      try {\n        return createAccessList(this, tx, block, DEFAULT_RETURN_FORMAT);\n      } catch (error) {\n        if (error instanceof ContractExecutionError) {\n          // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n          decodeContractErrorData(errorsAbi, error.innerError);\n        }\n        throw error;\n      }\n    });\n  }\n  _contractMethodSend(abi, params, errorsAbi, options, contractOptions) {\n    var _a, _b;\n    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;\n    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), {\n      input: undefined,\n      from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined\n    });\n    const tx = getSendTxParams({\n      abi,\n      params,\n      options: Object.assign(Object.assign({}, options), {\n        dataInputFill: this.config.contractDataInputFill\n      }),\n      contractOptions: modifiedContractOptions\n    });\n    const transactionToSend = sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\n      // TODO Should make this configurable by the user\n      checkRevertBeforeSending: false,\n      contractAbi: this._jsonInterface\n    });\n    // eslint-disable-next-line no-void\n    void transactionToSend.on('error', error => {\n      if (error instanceof ContractExecutionError) {\n        // this will parse the error data by trying to decode the ABI error inputs according to EIP-838\n        decodeContractErrorData(errorsAbi, error.innerError);\n      }\n    });\n    return transactionToSend;\n  }\n  _contractMethodDeploySend(abi, params, options, contractOptions) {\n    var _a, _b;\n    let modifiedContractOptions = contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options;\n    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), {\n      from: (_b = (_a = modifiedContractOptions.from) !== null && _a !== void 0 ? _a : this.defaultAccount) !== null && _b !== void 0 ? _b : undefined\n    });\n    const tx = getSendTxParams({\n      abi,\n      params,\n      options: Object.assign(Object.assign({}, options), {\n        dataInputFill: this.config.contractDataInputFill\n      }),\n      contractOptions: modifiedContractOptions\n    });\n    return sendTransaction(this, tx, DEFAULT_RETURN_FORMAT, {\n      transactionResolver: receipt => {\n        if (receipt.status === BigInt(0)) {\n          throw new Web3ContractError(\"code couldn't be stored\", receipt);\n        }\n        const newContract = this.clone();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        newContract.options.address = receipt.contractAddress;\n        return newContract;\n      },\n      contractAbi: this._jsonInterface,\n      // TODO Should make this configurable by the user\n      checkRevertBeforeSending: false\n    });\n  }\n  _contractMethodEstimateGas({\n    abi,\n    params,\n    returnFormat,\n    options,\n    contractOptions\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = getEstimateGasParams({\n        abi,\n        params,\n        options: Object.assign(Object.assign({}, options), {\n          dataInputFill: this.config.contractDataInputFill\n        }),\n        contractOptions: contractOptions !== null && contractOptions !== void 0 ? contractOptions : this.options\n      });\n      return estimateGas(this, tx, BlockTags.LATEST, returnFormat);\n    });\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _createContractEvent(abi, returnFormat = DEFAULT_RETURN_FORMAT) {\n    return (...params) => {\n      var _a;\n      const {\n        topics,\n        fromBlock\n      } = encodeEventABI(this.options, abi, params[0]);\n      const sub = new LogsSubscription({\n        address: this.options.address,\n        topics,\n        abi,\n        jsonInterface: this._jsonInterface\n      }, {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        subscriptionManager: this.subscriptionManager,\n        returnFormat\n      });\n      if (!isNullish(fromBlock)) {\n        // emit past events when fromBlock is defined\n        this.getPastEvents(abi.name, {\n          fromBlock,\n          topics\n        }, returnFormat).then(logs => {\n          logs.forEach(log => sub.emit('data', log));\n        }).catch(error => {\n          sub.emit('error', new SubscriptionError('Failed to get past events.', error));\n        });\n      }\n      (_a = this.subscriptionManager) === null || _a === void 0 ? void 0 : _a.addSubscription(sub).catch(error => {\n        sub.emit('error', new SubscriptionError('Failed to subscribe.', error));\n      });\n      return sub;\n    };\n  }\n  subscribeToContextEvents(context) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const contractThis = this;\n    this.context = context;\n    if (contractThis.syncWithContext) {\n      context.on(Web3ConfigEvent.CONFIG_CHANGE, event => {\n        contractThis.setConfig({\n          [event.name]: event.newValue\n        });\n      });\n    }\n  }\n}\n//# sourceMappingURL=contract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}